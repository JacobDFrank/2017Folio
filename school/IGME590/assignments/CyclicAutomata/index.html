<!doctype html>
<html lang='en'>
<!-- cd /Users/jacobfrank/GitHub/JacobDFrank.github.io/school/IGME590/assignments/CyclicAutomata -->
<!-- browserify index.js -o app.js -->
<!-- watchify index.js -v -o app.js -->

<head>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
    </style>

</head>

<body>
    <canvas id="myCanvas"></canvas>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script>


    <script type="x-shader/x-vertex" id="vertexShader">

        varying vec2 vUv; void main() { vUv = uv; vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 ); gl_Position = projectionMatrix * mvPosition; } // needed for a GLSL Vertex shader
    </script>

    <script  type="x-shader/x-fragment" id="fragmentShader">
        uniform float time;
        uniform vec2 resolution;
        uniform sampler2D tPrev;

        varying vec2 vUv;

        vec2 normalizedPosition() {
            return 2.0 * vUv + -1.0;
        }

        float rand(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        //
        // scene
        //

        const int R = 3; // Range: in the vicinity of Range
        const int T = 7; // Threshold: Number of neighbors with state required for state transition
        const int C = 7; // Colors: Number of Colors states (0..C-1)
        const bool N = false; // Neighborhood Types near the Neighborhood. Moore (NM) if false, Von Neumann (NN) if true

        float initialize(vec2 p) {


            // Random start
            float r = rand(gl_FragCoord.xy + vec2(40.0, 2000.0));
            return floor(r * float(C) + 1e-10) / float(C);
        }

        int cellState(vec2 delta) {
            //return int((float(C) * texture2D(tPrev, vec2(mod(vUv.x + delta.x * 3.0, 1.0), mod(vUv.y + delta.y, 1.0))).r) + 0.5);
            return int((float(C) * texture2D(tPrev, vec2(mod(vUv.x + delta.x, 1.0), mod(vUv.y + delta.y, 1.0))).r) + 0.5);
        }

        bool match(int mid, vec2 delta) {
            if (mid == cellState(delta))
                return true;

            return false;
        }

        int sumNM(int mid, vec2 d) {
            // Moore neighborhood (8近傍)

            int sum = 0;
            for (int x = -R; x <= R; ++x) {
                for (int y = -R; y <= R; ++y) {
                    if (x == 0 && y == 0)
                        continue;

                    if (match(mid, vec2(tan(float(x)) * d.x, cos(float(y)) * d.y))) // R3/T8/C6
                    // if (match(mid, vec2(sqrt(float(x)) * d.x, sqrt(float(y)) * d.y)))
                    // if (match(mid, vec2(atan(float(x)) * d.x, sqrt(float(y)) * d.y))) // R3/T10/C6
                    // if (match(mid, vec2(asin(float(x)) * d.x, (float(y)) * d.y))) // R3/T7/C6
                    //if (match(mid, vec2(exp(float(x)) * d.x, acos(float(y)) * d.y))) // R5/T14/C5
                    // if (match(mid, vec2((float(x)) * d.x, (float(y)) * d.y)))
                        sum += 1;
                }
            }
            return sum;
        }

        float calc() {
            // 1ピクセルの距離
            vec2 d = (1.0) / resolution;

            int cell = cellState(vec2(0.0, 0.0));

            // セルの次の状態を求める
            int mid = cell - 1;
            if (mid < 0) mid = C - 1;

            // 次の状態を持つ近傍の数を数える
            int sum = 0;

            sum = sumNM(mid, d);

            // セルの次の状態を決定する
            if (T <= sum)
                cell = mid;

            return float(cell) / float(C);
        }

        //
        // main
        //
        void main() {
            float r = 0.0;
            if (time < 1.0) {
                vec2 p = normalizedPosition();
                r = initialize(p);
            } else {
                r = calc();
            }

            gl_FragColor = vec4(
                r,
                mod(r * 2.88, 1.0),
                mod(r * 10.57, 1.0),
                1.0);
        }
    </script>

    <script src='./app.js'></script>

</body>


<html>
