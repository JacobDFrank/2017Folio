<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Pulsating</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        @import url('https://fonts.googleapis.com/css?family=Oswald|Roboto');
        * {
            margin: 0;
            padding: 0;
        }
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .text {
            margin-top: 40%;
            display: flex;
            flex-direction: column;
        }
        h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 55px;
        }
        h6 {
            font-family: 'Roboto', sans-serif;
            font-size: 22;
        }
        canvas {
            position:absolute;
            top:0;
            left:0;
            width:100%;
            height:100%;
            z-index:-1;
        }
    </style>
</head>

<body>
    <div id="ball"></div>
    <div class = "text">
        <h2>JACOB FRANK</h2>
        <h6>Developer and Designer</h6>
    </div>

    <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js'></script>

    <script>
        var scene, renderer, camera, mesh, geometry, lights = [];
        var wireframe = false,
            material;
        // var flatten_modifier = 100;
        var phone = 35,
            tabletPortrait, size = 95,
            desktop = tabletLandscape = 76,
            bigDesktop = 82, bigDesktopBlue = bigDesktop/2;

        var createIndexedSphereGeometry = function(width, length) {
            var geom = new THREE.BufferGeometry();

            var vertices = [];
            var indices = [];
            var uvs = [];
            var width1 = width + 1;
            var length1 = length + 1;
            for (var i = 0; i < width1; i++) {
                for (var j = 0; j < length1; j++) {
                    vertices.push(i / width, 0, j / length);
                    uvs.push(i / width, j / length);
                }
            }

            for (var i = 0; i < width; i++) {
                for (var j = 0; j < length; j++) {
                    var a = i * length1 + j;
                    var b = i * length1 + j + 1;
                    var c = (i + 1) * length1 + j;
                    var d = (i + 1) * length1 + j + 1;

                    indices.push(a, c, b);
                    indices.push(b, c, d);
                }
            }

            var positions = new Float32Array(vertices);
            var index = new Uint32Array(indices);
            var uv = new Float32Array(uvs);

            geom.addAttribute('position', new THREE.BufferAttribute(positions, 3));
            geom.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));
            geom.setIndex(new THREE.BufferAttribute(index, 1));

            return geom;
        }

        var main = function(geom, radius) {
            var pos = geom.attributes.position.array;
            var uvs = geom.attributes.uv.array;

            var pi = Math.PI;

            for (var i = 0, u = 0, v = 1; i < pos.length; i += 3, u += 2, v += 2) {
                pos[i] = radius * Math.sin(uvs[u] * pi) * Math.cos(uvs[v] * 2 * pi);
                pos[i + 1] = radius * Math.sin(uvs[u] * pi) * Math.sin(uvs[v] * 2 * pi);
                pos[i + 2] = radius * Math.cos(uvs[u] * pi);
            }
            geom.addAttribute('base_position', geom.attributes.position.clone())
            geom.computeVertexNormals();
        }

        initScene = function() {
            scene = new THREE.Scene();

            // Renderer
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: false
            });
            renderer.setClearColor(0xf8f8f8, 1.0);
            renderer.autoClearColor = true;
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById("ball").appendChild(renderer.domElement);

            // My Light
            lights[0] = new THREE.PointLight(0xacc2df, .2, 0);
            lights[0].position.set(0, 400, 400);

            scene.add(lights[0]);

            // My Camera
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 550);
            //   camera.setLens( flatten_modifier );
            //   camera.position.z = flatten_modifier * 9;

        }
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function rotateObject(object, degreeX = 0, degreeY = 0, degreeZ = 0) {

            degreeX = (degreeX * Math.PI) / 180;
            degreeY = (degreeY * Math.PI) / 180;
            degreeZ = (degreeZ * Math.PI) / 180;

            object.rotateX(degreeX);
            object.rotateY(degreeY);
            object.rotateZ(degreeZ);

        }

        var init = function() {
            initScene();
            var sizeX = sizeY = sizeZ = size;
            mesh = new THREE.Object3D();
            mesh.scale.set(sizeX, sizeY, sizeZ);
            rotateObject(mesh, -106, -45, -180);

            geometry = createIndexedSphereGeometry(250, 250);
            main(geometry, 1);

            material = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0xE25046,
                metalness: 1.0,
                transparent: true,
                opacity: 0.5,
                wireframe: wireframe
            });
            material1 = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0x46D8E2,
                metalness: 1.0,
                transparent: true,
                opacity: 0.5,
                wireframe: wireframe
            });
            sphere = new THREE.Mesh(geometry, material);
            sphere1 = new THREE.Mesh(geometry, material1);

            mesh.add(sphere);
            mesh.add(sphere1);

            scene.add(mesh);
            animate();
        }

        window.onmousemove = function(e) {}

        var time = 0;
        var modifyGeometry = function() {
            var pos = geometry.attributes.position.array;
            var base_pos = geometry.attributes.base_position.array;
            var uvs = geometry.attributes.uv.array;

            for (var i = 0, j = 0; i < pos.length; i += 6, j += 4) {
                var scale = 0.01 * Math.cos(uvs[j] * 7 + time * 0.01);
                scale += 0.05 * Math.cos(uvs[j + 1] * 9 + time * 0.05);

                for (var k = 4; k < 6; k += 10) {
                    scale += (0.05 * k) * Math.cos(uvs[j] * 9 * k + (k + time * 0.05));
                    scale += (0.0 * k) * Math.cos(uvs[j + 1] * 7 * k + (k + time * 0.05));
                }

                scale *= scale * 1.7 * Math.sin(time * 0.04 + uvs[j] * 4);

                pos[i] = base_pos[i] * (1 + scale);
                pos[i + 1] = base_pos[i + 1] * (1 + scale);
                pos[i + 2] = base_pos[i + 2] * (1 + scale);
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        var animate = function() {
            time++;



            if (window.innerWidth < 599) {
                mesh.scale.set(phone, phone, phone);
            }
            if (window.innerWidth > 600) {
                tabletPortrait = (55 + (window.innerWidth - 600) * .07);
                mesh.scale.set(tabletPortrait, tabletPortrait, tabletPortrait);
                // prompt(tabletPortrait);
            }
            if (window.innerWidth > 900) {
                mesh.scale.set(tabletLandscape, tabletLandscape, tabletLandscape);
            }
            if (window.innerWidth > 1200) {
                desktop = (76 + (window.innerWidth - 1200) * .1);
                mesh.scale.set(desktop, desktop, desktop);
            }
            if (window.innerWidth > 1800) {
                mesh.scale.set(bigDesktop, bigDesktop, bigDesktop);

            }
            sphere1.position.x = -1;
            sphere1.position.y = -6;
            sphere1.position.z = -3.5;

            scene.requestFrame = requestAnimationFrame(animate);

            modifyGeometry();

            renderer.render(scene, camera);
        }

        var update = function() {

        }

        init();
    </script>

</body>

</html>
